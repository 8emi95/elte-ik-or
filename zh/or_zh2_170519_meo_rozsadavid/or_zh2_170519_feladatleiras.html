<!DOCTYPE html>
<!-- saved from url=(0052)https://bead.inf.elte.hu/submission-list?asg-key=221 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>BE-AD Assignment Management System</title><link rel="shortcut icon" href="https://bead.inf.elte.hu/icon.ico"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content=""><meta name="author" content=""><script src="./BE-AD Assignment Management System_files/jquery.js.download"></script><link type="text/css" href="./BE-AD Assignment Management System_files/jquery-ui.css" rel="stylesheet"><script src="./BE-AD Assignment Management System_files/jquery-ui.js.download"></script><script src="./BE-AD Assignment Management System_files/moment.js.download"></script><link type="text/css" href="./BE-AD Assignment Management System_files/bootstrap.min.css" rel="stylesheet"><link type="text/css" href="./BE-AD Assignment Management System_files/bootstrap.custombutton.css" rel="stylesheet"><script src="./BE-AD Assignment Management System_files/bootstrap.min.js.download"></script><link type="text/css" href="./BE-AD Assignment Management System_files/bootstrap-combobox.css" rel="stylesheet"><script src="./BE-AD Assignment Management System_files/bootstrap-combobox.js.download"></script><link type="text/css" href="./BE-AD Assignment Management System_files/bootstrap-datetimepicker.min.css" rel="stylesheet"><script src="./BE-AD Assignment Management System_files/bootstrap-datetimepicker.min.js.download"></script><script src="./BE-AD Assignment Management System_files/DynamicContents.js.download"></script><link type="text/css" href="./BE-AD Assignment Management System_files/katex.min.css" rel="stylesheet"><script src="./BE-AD Assignment Management System_files/katex.min.js.download"></script><script>window.onload = function(){ var mathElements = document.getElementsByClassName("math"); for (var i=0; i < mathElements.length; i++) { var texText = mathElements[i].firstChild; katex.render(texText.data, mathElements[i]); }}</script></head><body><div class="navbar navbar-default navbar-fixed-top"><style>.body{padding-top:70px}</style><div class="container"><div class="navbar-header"><a class="navbar-brand" href="https://bead.inf.elte.hu/home">BE-AD</a><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button></div><div class="collapse navbar-collapse navbar-ex1-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="https://bead.inf.elte.hu/notifications" id="link-notifications">Notifications (5)</a></li><li><a id="hdctd">19:46</a><script>hdctdcountdown();function hdctdcountdown() {var minsecs = 60;var hoursecs = minsecs * 60;var daysecs = hoursecs* 24;var mstime = 1200 * 1000;var timestamp = new Date;var interval = setInterval(function() {var el = document.getElementById("hdctd");var now = new Date;var dt = now - timestamp;timestamp = now;mstime = mstime - dt;var time = Math.round( mstime / 1000 );if(time < 0) {el.innerHTML = "--:--";clearInterval(interval);return;}var edays   = Math.floor( time / daysecs );var ehours1 = time % daysecs;var ehours  = Math.floor( ehours1 / hoursecs );if (ehours < 10) ehours = "0" + ehours;var emins1  = ehours1 % hoursecs;var emins   = Math.floor( emins1 / minsecs );if (emins < 10) emins = "0" + emins;var esecs   = emins1 % minsecs;if (esecs < 10) esecs = "0" + esecs;var text = emins + ':' + esecs;el.innerHTML = text;}, 1000);}</script></li><li><a>METAMORF / YJ3VFM</a></li><li><a href="https://bead.inf.elte.hu/profile" id="link-profile">Profile</a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-md-12"><hr></div></div><div class="row"><div class="col-md-12"><div class="page-header"><h2>Submissions</h2></div></div></div><div class="row"><div class="col-md-12"><table class="table table-bordered table-condensed table-hover table-striped"><tbody><tr><td><b>Course, group:</b></td><td>Osztott rendszerek (BSc)</td></tr><tr><td><b>Teacher:</b></td><td>Kitlei Robert Laszlo, Koszegi Judit, Mészáros Mónika</td></tr><tr><td><b>Assignment:</b></td><td>Osztott ZH 2017.05.19.</td></tr><tr><td><b>Deadline:</b></td><td>2017-05-19, 20:00:00</td></tr></tbody></table></div></div><div class="row"><div class="col-md-12">There are no submissions.</div></div><div class="row"><div class="col-md-12"><h2>Assignment Description</h2></div></div><div style="margin-left:0px; background: lightgray"><h2 id="feltételek">Feltételek</h2>
<ul>
<li><p>A ZH megoldása során <strong>tilos</strong> más ember (kivéve a felügyelő gyakorlatvezetők) segítségét bármilyen módon kérni, együttműködni, vagy segítséget adni.</p></li>
<li><p>Használható eszközök:</p>
<ul>
<li><p><a href="https://bead.inf.elte.hu/files/java/api/">Java API dokumentáció</a></p></li>
<li><a href="http://exam.inf.elte.hu/osztott.zip">Tömörített fájl</a>, amely tartalmazza
<ul>
<li>a gyakorlatvezetők anyagait</li>
<li>az alábbi alapfeladathoz tartozó tesztelőt</li>
<li>a beadandó kiírását (ebben megtalálható a hsqldb jar fájlja is)</li>
</ul></li>
</ul></li>
</ul>
<h2 id="az-elkészítendő-megoldásról">Az elkészítendő megoldásról</h2>
<ul>
<li><p>A kettesért az alapfeladatot kell megoldani, minden további jegyért egy választható feladatot.</p></li>
<li><p>A választható feladat megoldásához az alapfeladatot kell bővíteni. Ehhez másold át az alapfeladat megoldását a megfelelő csomagba (pl. a <code>zh20170519.alapfeladat</code> csomagból a <code>zh20170519.feladatA</code> csomagba), és alakítsd át/bővítsd a megoldást a leírás szerint.</p></li>
</ul>
<h2 id="beadás">Beadás</h2>
<p>A BE-AD-ban.</p>
<h2 id="tesztelés">Tesztelés</h2>
<p>Az alapfeladathoz <a href="http://exam.inf.elte.hu/osztott.zip">elérhető egy egyszerű tesztfájl, bemeneti fájlok és minta kimenet</a>, ezen belül a <code>test.zip</code>-be csomagolva. A <code>Test.java</code> osztály tartalmaz főprogramot, ezt kell futtatni (parancssori paramétereket nem igényel). A futás végén a tesztelő összehasonlítja a standard outputon megjelenő szöveget a mintakimenettel, és jelzi, ha különbözőek.</p>
<p>Akkor fog jól működni a tesztelő, ha a csomag - és osztálynevek a feladatleírásnak megfelelőek. Megjegyzés: az elvárt mintakimenethez képest (<code>output.txt</code>) a valós futáskor az egyes sorok kis mértékben felcserélődhetnek a többszálú futtatás nemdeterminisztikussága miatt (a kliensek és a szerver külön szálakon futnak), de a sorokban lévő tartalmaknak egyezőnek kell lennie. Ez azt is jelenti, hogy ha a futás végén megjelenő hibaüzenet szerint a kimenet és a mintakimenet sorainak száma tér el, akkor biztosan hibás a megoldás.</p>
<h2 id="elégséges-socketes-szerver-és-kliens">Elégséges: Socketes szerver és kliens</h2>
<p>Készíts egy alkalmazást, amellyel leegyszerűsített rulettet lehet játszani. Ahogy az igazi rulettben is, a játékosok téteket tehetnek majd, hogy a rulettkeréken megpörgetett golyó (esetünkben egy generált véletlen szám) a 0 és 36 közötti egész számok közül melyikre esik. Az igazi rulettben a számok egy részhalmazára is lehet tétet tenni (pl. párosak, 18-nál nagyobbak), de ezt mi most nem fogjuk engedni, csak konkrét számra lehet tétet tenni.</p>
<h3 id="rouletteserver">RouletteServer</h3>
<p>Készítsd el a <code>zh20170519.alapfeladat.RouletteServer</code> osztályt, mely tartalmazzon főprogramot. A szerver tetszőleges portot használhat.</p>
<ul>
<li><p>A főprogram egy egész számot kap parancssori paraméterként, mely azt mondja majd meg, hogy hány játékos játszik. Feltehetjük, hogy a paraméter helyes.</p></li>
<li><p>Induláskor a szerver hozzon létre és tároljon el egy véletlen generátort a következő utasítással: <code>new Random(123456);</code>. A későbbiekben mindig ezen objektum egész paraméterű <code>nextInt</code> metódusával sorsoljuk a véletlen számokat. Így minden egyes futásnál ugyanazokat a számokat fogjuk megkapni, ami a tesztelhetőség miatt fontos.</p></li>
<li><p>Ezután fogadja <code>Socket</code>en keresztül az előre megadott számú klienst. Mindegyiktől kérje el a nevét, majd kezdje meg az első kört.</p></li>
<li><p>Egy körben mindegyik kliens szóhoz jut (egymás után). A szervernek az alábbi három fajta üzenetet küldhetik:</p>
<ul>
<li><p><code>"bet n"</code>, ahol <code>n</code> egy <code>0</code> és <code>36</code> közti egész szám (<code>0</code> és <code>36</code> is lehet). Ez azt jelenti, hogy a játékos <code>1</code> érmét szeretne helyezni a megadott számra. Egy játékosnak annyiszor kell küldenie a <code>"bet n"</code> üzenetet ugyanazzal az <code>n</code> számmal, ahány érmét arra a számra kíván feltenni.</p></li>
<li><p><code>"finish"</code>, mellyel azt jelzi a játékos, hogy ebben a körben nem akar több tétet megtenni,</p></li>
<li><p><code>"out"</code>, mely azt jelzi, hogy a játékos kilép, nem akar többet játszani. Ezt az üzenetet csak akkor küldheti a játékos, ha az adott körben nem tett meg tétet (tehát ha az <code>"out"</code> üzenet az egyetlen, melyet az adott körben küld).</p></li>
</ul>
<p>Feltehetjük, hogy a kliensek betartják a fent leírtakat, ezt nem kell ellenőrizni.</p></li>
<li><p>Mikor a szerver üzenetet kap valamelyik klienstől, azt írja ki a képernyőre az alábbi formában: <code>"Server&gt; N: M"</code>, ahol az <code>N</code> a kliens neve, az <code>M</code> pedig a kapott üzenet.</p></li>
<li><p>A <code>"bet"</code> üzeneteket tárolja le a szerver. A <code>"finish"</code> esetén továbbléphet a következő kliensre, hogy tőle is megkapja az üzeneteket.</p></li>
<li><p>Ha egy körben végigért a klienseken, akkor generáljon egy legalább <code>0</code>, legfeljebb <code>36</code> véletlen egész számot, és nézze meg, hogy kik nyertek a tétjeik alapján. Minden játékosnak egy egész számot kell elküldeni, azt, hogy mennyit nyert vagy vesztett az adott körben. Minden vesztes (rossz számra tett) tétet <code>-1</code>-gyel, a nyertes (jó számra tett) téteket <code>35</code>-tel számítjuk bele a véreredménybe.</p></li>
<li><p>Ha egy játékos <code>"out"</code> üzenetet küldött, akkor neki már nem válaszolunk, és több üzenetet sem várunk tőle. Végérvényesen kiszállt a játékból.</p></li>
<li><p>Ha minden játékos kiszállt a játékból, a szerver álljon le.</p></li>
</ul>
<h3 id="rouletteclient">RouletteClient</h3>
<p>Készítsd el a <code>zh20170519.alapfeladat.RouletteClient</code> osztályt, mely tartalmazzon főprogramot.</p>
<ul>
<li><p>Két parancssori argumentumot kap, az első a neve, a második pedig egy fájlnév lesz, ez a fájl fogja tartalmazni a kliens fogadásait.</p></li>
<li><p>A kliens kapcsolódjon a szerverhez, és küldje el a nevét. Ezután nyissa meg a megadott fájlt, és olvassa ki belőle soronként a tartalmát. (A fájlról feltehetjük, hogy létezik és a tartalma megfelel az alábbi feltételeknek.)</p>
<ul>
<li><p>Egy sor két egész számot tartalmaz egy szóközzel elválasztva: <code>n</code> és <code>k</code>, ami azt jelenti, hogy az <code>n</code> számra kell tennie <code>k</code> érmét. Küldjön el a szerver <code>k</code> db <code>"bet n"</code> üzenetet.</p></li>
<li><p>Ha <code>n</code> és <code>k</code> értéke is <code>-1</code>, az azt jelenti, hogy vége a körnek, a kliens nem kell, hogy több tétet tegyen. Ekkor értelemszerűen nem küld <code>"bet n"</code> üzenetet a kliens, hanem helyette egy <code>"finish"</code> üzenetet kell. A <code>"finish"</code> üzenet elküldése után várja meg a szerver válaszát, mely egy egész szám. Ha az negatív, akkor írja ki a <code>"n&gt; I lost k"</code> szöveget a képernyőre, ahol <code>k</code> a kapott negatív szám <code>(-1)</code>-szerese. Ha pozitív vagy nulla, akkor írja ki a <code>"n&gt; I won k"</code> a képernyőre, ahol <code>k</code> a kapott pozitív szám. Az <code>n</code> mindkét esetben a kliens neve legyen.</p></li>
<li><p>Ha a fájl végére ért, akkor elküldi az <code>"out"</code> üzenetet, és kilép. (Feltehetjük, hogy a fájl utolsó nemüres sora <code>"-1 -1"</code>.)</p></li>
</ul></li>
</ul>
<h2 id="a-többszálúsítás">A: Többszálúsítás</h2>
<p>A megoldás fájljait a <code>zh20170519.feladatA</code> csomagba készítsd el, miután ide átmásoltad az alapfeladat megoldását.</p>
<p>A szervert egészítsük ki úgy, hogy engedjen több rulettjátékot is játszani egyszerre. Mikor a megadott számú kliens csatlakozott, indítson egy új szálat, melyen az addig bejelentkezett kliensek között bonyolítja le a játékot. Ezután várjon új kliensekre.</p>
<p>A szerver ebben az esetben sosem fog leállni, csak az indított új szálak. A szálak külön véletlengenerátort használjanak.</p>
<p>A szerver tartalmazzon egy számlálót, mely megadja, hogy hány játék fut éppen. Mikor egy új szál elindul egy új játéknak, a szál növelje meg ezt a számlálót. Mikor éppen le akar állni, csökkentse. Mindkét esetben, mikor változtatjuk a számláló értékét, írjuk ki a képernyőre a következő üzenetet: <code>"Server&gt; #active games: c"</code>, ahol <code>c</code> a számláló frissített értéke.</p>
<h2 id="b-távoli-metódushívás-rmi">B: Távoli metódushívás (RMI)</h2>
<p>A megoldás fájljait a <code>zh20170519.feladatB</code> csomagba készítsd el, miután ide átmásoltad az alapfeladat megoldását.</p>
<p>Alakítsuk át a szervert úgy, hogy a körök kiértékelését ne ő, hanem egy háttérben futó alkalmazás futtassa, melyet távoli metódushívásokkal fogunk elérni.</p>
<p>Ehhez készítsük el <code>RouletteDeploy</code> osztályt, mely tartalmazzon főprogramot. A főprogram indítson egy új registry-t a <code>8888</code> porton, és jegyezzen be egy távoli objektumot <code>"roulette"</code> néven, mely megvalósítja a <code>RouletteIface</code> távoli interfészt. Az interfész alábbi metódusokat biztosítsa:</p>
<ol style="list-style-type: decimal">
<li><p><code>void newRound()</code>: új kört indítunk, az eddigi téteket és eredményeket töröljük.</p></li>
<li><p><code>void placeBet(String name, int num)</code>: a <code>name</code> nevű játékos a <code>num</code> számra tett tétet. Értelemszerűen csak az <code>newRound</code> után és a következő <code>endRound</code> előtt hívható.</p></li>
<li><p><code>void endRound()</code>: a körnek vége, több tét már nem fog érkezni. Ilyenkor "pörgetünk" (generáljuk a megfelelő véletlen számot).</p></li>
<li><p><code>int getWinningsOf(String name)</code>: lekérdezi egy adott nevű felhasználóra, hogy mennyit nyert/vesztett. Értelemszerűen csak az <code>endRound</code> után és a következő <code>newRound</code> előtt hívható.</p></li>
</ol>
<p><em>Feltehetjük, hogy a metódusokat csak helyes sorrendben hívják meg.</em></p>
<p>A szerver a kliensekhez való kapcsolódás után kapcsolódjon ehhez a bejegyzett távoli objektumhoz. Minden kör elején hívja meg a <code>newRound</code> metódust, majd minden egyes tét beérkezésekor a megfelelően paraméterezett <code>placeBet</code> metódust. Mikor mindegyik aktív kliens befejezte a körét, hívjuk meg az <code>endRound</code> metódust, majd a klienseken végigmenve mindegyikhez kérjük le és küldjük el az ő nyereményét/veszteségét a <code>getWinningsOf</code> metódus segítségével.</p>
<h2 id="c-szerializáció">C: Szerializáció</h2>
<p>A megoldás fájljait a <code>zh20170519.feladatC</code> csomagba készítsd el, miután ide átmásoltad az alapfeladat megoldását.</p>
<p>Készítsük el a következő szerializálható típusokat:</p>
<ul>
<li><p><code>RouletteBet</code>: egy megtett tétet ír le. Tartalmaznia kell, hogy milyen nevű játékos tette meg melyik számot (ez 1 érme feltevését jelenti az adott számra).</p></li>
<li><p><code>RouletteRound</code>: egy lejátszott kört ábrázol. Tartalmaznia kell a "pörgetett" (generált) számot és a megtett téteket.</p></li>
</ul>
<p>A szerver e két típus segítségével dokumentáljon minden kört, és mentse ki őket szerializálva a <code>roulette.dat</code> állományba.</p>
<p>Készíts egy egyszerű <code>ReadRoulette</code> osztályt, mely főprogramot tartalmaz. Olvassa be a <code>roulette.dat</code> állományban található adatokat, és írja ki az adatokat a következő formában:</p>
<ul>
<li><p>Egy körről: <code>"Round R with winning number N:"</code> ahol az <code>R</code> a kör sorszáma (<code>1</code>-től egyesével), az <code>N</code> pedig a "pörgetett" nyerőszám.</p></li>
<li><p>Ez alá az adott körben tett minden egyes tét szerepeljen egy külön sorban: <code>"Player P played bet on N"</code>, ahol <code>P</code> a játékos neve, <code>N</code> pedig a megtett szám.</p></li>
</ul>
<h2 id="d-adatbázis-kezelés">D: Adatbázis-kezelés</h2>
<p>A megoldás fájljait a <code>zh20170519.feladatD</code> csomagba készítsd el, miután ide átmásoltad az alapfeladat megoldását.</p>
<p>A szerver nyisson egy adatbáziskapcsolatot, és egy megfelelő táblába tárolja le, hogy melyik kliens mennyit nyert vagy vesztett összesen. Kezdetben mindegyik klienshez mentse le, hogy az egyenlege <code>0</code>, majd minden kör végén adja ehhez hozzá a kliens abban a körben elért nyereményét/veszteségét. A klienseket a nevükkel azonosítjuk.</p>
<p>A szerver leállása előtt írja ki az adatbázis alapján, hogy kinek volt a legtöbb nyereménye.</p></div><div class="row"><div class="col-md-12"><hr></div></div></div></body></html>